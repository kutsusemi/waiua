/*
 * Valorant API
 *
 * Valorant API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct PartiesV1PartiesCustomgameconfigsGet200ResponseQueuesInner {
    /// Queue ID
    #[serde(rename = "QueueID")]
    pub queue_id: String,
    #[serde(rename = "Enabled")]
    pub enabled: bool,
    #[serde(rename = "TeamSize")]
    pub team_size: f64,
    #[serde(rename = "NumTeams")]
    pub num_teams: f64,
    #[serde(rename = "MaxPartySize")]
    pub max_party_size: f64,
    #[serde(rename = "MinPartySize")]
    pub min_party_size: f64,
    #[serde(rename = "InvalidPartySizes")]
    pub invalid_party_sizes: Vec<f64>,
    #[serde(rename = "MaxPartySizeHighSkill")]
    pub max_party_size_high_skill: f64,
    #[serde(rename = "HighSkillTier")]
    pub high_skill_tier: f64,
    #[serde(rename = "MaxSkillTier")]
    pub max_skill_tier: f64,
    #[serde(rename = "AllowFullPartyBypassSkillRestrictions")]
    pub allow_full_party_bypass_skill_restrictions: bool,
    #[serde(rename = "Mode")]
    pub mode: String,
    #[serde(rename = "IsRanked")]
    pub is_ranked: bool,
    #[serde(rename = "IsTournament")]
    pub is_tournament: bool,
    #[serde(rename = "RequireRoster")]
    pub require_roster: bool,
    #[serde(rename = "Priority")]
    pub priority: f64,
    #[serde(rename = "PartyMaxCompetitiveTierRange")]
    pub party_max_competitive_tier_range: f64,
    #[serde(rename = "PartyMaxCompetitiveTierRangePlacementBuffer")]
    pub party_max_competitive_tier_range_placement_buffer: f64,
    #[serde(rename = "FullPartyMaxCompetitiveTierRange")]
    pub full_party_max_competitive_tier_range: f64,
    #[serde(rename = "PartySkillDisparityCompetitiveTiersCeilings")]
    pub party_skill_disparity_competitive_tiers_ceilings: std::collections::HashMap<String, f64>,
    #[serde(rename = "UseAccountLevelRequirement")]
    pub use_account_level_requirement: bool,
    #[serde(rename = "MinimumAccountLevelRequired")]
    pub minimum_account_level_required: f64,
    #[serde(rename = "GameRules")]
    pub game_rules: std::collections::HashMap<String, String>,
    #[serde(rename = "SupportedPlatformTypes")]
    pub supported_platform_types: Vec<SupportedPlatformTypes>,
    #[serde(rename = "DisabledContent")]
    pub disabled_content: Vec<serde_json::Value>,
    #[serde(rename = "queueFieldA")]
    pub queue_field_a: Vec<serde_json::Value>,
    #[serde(rename = "NextScheduleChangeSeconds")]
    pub next_schedule_change_seconds: f64,
    #[serde(rename = "TimeUntilNextScheduleChangeSeconds")]
    pub time_until_next_schedule_change_seconds: f64,
    /// Array of strings in the format of \"map:weight\"
    #[serde(rename = "MapWeights")]
    pub map_weights: Vec<String>,
}

impl PartiesV1PartiesCustomgameconfigsGet200ResponseQueuesInner {
    pub fn new(
        queue_id: String,
        enabled: bool,
        team_size: f64,
        num_teams: f64,
        max_party_size: f64,
        min_party_size: f64,
        invalid_party_sizes: Vec<f64>,
        max_party_size_high_skill: f64,
        high_skill_tier: f64,
        max_skill_tier: f64,
        allow_full_party_bypass_skill_restrictions: bool,
        mode: String,
        is_ranked: bool,
        is_tournament: bool,
        require_roster: bool,
        priority: f64,
        party_max_competitive_tier_range: f64,
        party_max_competitive_tier_range_placement_buffer: f64,
        full_party_max_competitive_tier_range: f64,
        party_skill_disparity_competitive_tiers_ceilings: std::collections::HashMap<String, f64>,
        use_account_level_requirement: bool,
        minimum_account_level_required: f64,
        game_rules: std::collections::HashMap<String, String>,
        supported_platform_types: Vec<SupportedPlatformTypes>,
        disabled_content: Vec<serde_json::Value>,
        queue_field_a: Vec<serde_json::Value>,
        next_schedule_change_seconds: f64,
        time_until_next_schedule_change_seconds: f64,
        map_weights: Vec<String>,
    ) -> PartiesV1PartiesCustomgameconfigsGet200ResponseQueuesInner {
        PartiesV1PartiesCustomgameconfigsGet200ResponseQueuesInner {
            queue_id,
            enabled,
            team_size,
            num_teams,
            max_party_size,
            min_party_size,
            invalid_party_sizes,
            max_party_size_high_skill,
            high_skill_tier,
            max_skill_tier,
            allow_full_party_bypass_skill_restrictions,
            mode,
            is_ranked,
            is_tournament,
            require_roster,
            priority,
            party_max_competitive_tier_range,
            party_max_competitive_tier_range_placement_buffer,
            full_party_max_competitive_tier_range,
            party_skill_disparity_competitive_tiers_ceilings,
            use_account_level_requirement,
            minimum_account_level_required,
            game_rules,
            supported_platform_types,
            disabled_content,
            queue_field_a,
            next_schedule_change_seconds,
            time_until_next_schedule_change_seconds,
            map_weights,
        }
    }
}
///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SupportedPlatformTypes {
    #[serde(rename = "PC")]
    Pc,
}

impl Default for SupportedPlatformTypes {
    fn default() -> SupportedPlatformTypes {
        Self::Pc
    }
}
