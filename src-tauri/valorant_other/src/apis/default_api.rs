/*
 * Valorant API
 *
 * Valorant API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for typed errors of method [`auth_riotgames_com_api_v1_authorization_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthRiotgamesComApiV1AuthorizationPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_riotgames_com_api_v1_authorization_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthRiotgamesComApiV1AuthorizationPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_riotgames_com_authorizeredirect_urihttps3_a2_f2_fplayvalorant_com2_fopt_inclient_idplay_valorant_web_prodresponse_typetoken20id_tokennonce1scopeaccount20openid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthRiotgamesComAuthorizeredirectUrihttps3A2F2FplayvalorantCom2FoptInclientIdplayValorantWebProdresponseTypetoken20idTokennonce1scopeaccount20openidGetError
{
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_riotgames_com_userinfo_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthRiotgamesComUserinfoGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`clientconfig_rpg_riotgames_com_api_v1_config_playerapp_riot20_client_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClientconfigRpgRiotgamesComApiV1ConfigPlayerappRiot20ClientGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`entitlements_auth_riotgames_com_api_token_v1_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EntitlementsAuthRiotgamesComApiTokenV1PostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`riot_geo_pas_si_riotgames_com_pas_v1_product_valorant_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RiotGeoPasSiRiotgamesComPasV1ProductValorantPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`riot_geo_pas_si_riotgames_com_pas_v1_service_chat_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RiotGeoPasSiRiotgamesComPasV1ServiceChatGetError {
    UnknownValue(serde_json::Value),
}

/// Prepare cookies for auth request
pub async fn auth_riotgames_com_api_v1_authorization_post(
    configuration: &configuration::Configuration,
) -> Result<
    models::AuthRiotgamesComApiV1AuthorizationPut200Response,
    Error<AuthRiotgamesComApiV1AuthorizationPostError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}//auth.riotgames.com/api/v1/authorization",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthRiotgamesComApiV1AuthorizationPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Submits a multi-factor authentication code for login
pub async fn auth_riotgames_com_api_v1_authorization_put(
    configuration: &configuration::Configuration,
) -> Result<
    models::AuthRiotgamesComApiV1AuthorizationPut200Response,
    Error<AuthRiotgamesComApiV1AuthorizationPutError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}//auth.riotgames.com/api/v1/authorization",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthRiotgamesComApiV1AuthorizationPutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a new token using the cookies from a previous authorization request   Use the saved cookies from [PUT Auth Request] (specifically the `ssid` cookie). The auth token and id token can be found from the url this request redirects to.      It's recommended to use this endpoint instead of storing the password and sending it again.      There are ongoing tests at documented at <https://github.com/techchrism/riot-auth-test> that test for auth lifespan using different cookie strategies.   Currently, it appears refreshing with just the `ssid` cookie is only stable for one week and refreshing with all auth cookies is stable for three weeks.      On a successful response, the 301 redirect location header will be of the format: > ```https://playvalorant.com/opt_in#access_token={access token}&scope=openid&iss=https%3A%2F%2Fauth.riotgames.com&id_token={id token}&token_type=Bearer&session_state={session state}&expires_in=3600```    On an unsuccessful response, the 301 redirect location header will be of the format: > ```https://authenticate.riotgames.com/login?client_id=play-valorant-web-prod&nonce=1&redirect_uri=https%3A%2F%2Fauth.riotgames.com%2Fauthorize%3Fclient_id%3Dplay-valorant-web-prod%26nonce%3D1%26redirect_uri%3Dhttps%253A%252F%252Fplayvalorant.com%252Fopt_in%26response_type%3Dtoken%2520id_token&response_type=token%20id_token&method=riot_identity```
pub async fn auth_riotgames_com_authorizeredirect_urihttps3_a2_f2_fplayvalorant_com2_fopt_inclient_idplay_valorant_web_prodresponse_typetoken20id_tokennonce1scopeaccount20openid_get(configuration: &configuration::Configuration, ) -> Result<models::AuthRiotgamesComApiV1AuthorizationPut200Response, Error<AuthRiotgamesComAuthorizeredirectUrihttps3A2F2FplayvalorantCom2FoptInclientIdplayValorantWebProdresponseTypetoken20idTokennonce1scopeaccount20openidGetError>>{
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}//auth.riotgames.com/authorize?redirect_uri=https%3A%2F%2Fplayvalorant.com%2Fopt_in&client_id=play_valorant_web_prod&response_type=token%20id_token&nonce=1&scope=account%20openid", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthRiotgamesComAuthorizeredirectUrihttps3A2F2FplayvalorantCom2FoptInclientIdplayValorantWebProdresponseTypetoken20idTokennonce1scopeaccount20openidGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the PUUID and other info from a token
pub async fn auth_riotgames_com_userinfo_get(
    configuration: &configuration::Configuration,
) -> Result<models::AuthRiotgamesComUserinfoGet200Response, Error<AuthRiotgamesComUserinfoGetError>>
{
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}//auth.riotgames.com/userinfo",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthRiotgamesComUserinfoGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets the config file used by the Riot Client. This includes a ton of info, most of it undocumented.
pub async fn clientconfig_rpg_riotgames_com_api_v1_config_playerapp_riot20_client_get(
    configuration: &configuration::Configuration,
    x_riot_entitlements_jwt: &str,
) -> Result<
    models::ClientconfigRpgRiotgamesComApiV1ConfigPlayerAppRiot20ClientGet200Response,
    Error<ClientconfigRpgRiotgamesComApiV1ConfigPlayerappRiot20ClientGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}//clientconfig.rpg.riotgames.com/api/v1/config/player?app=Riot%20Client",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header(
        "X-Riot-Entitlements-JWT",
        x_riot_entitlements_jwt.to_string(),
    );
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<
            ClientconfigRpgRiotgamesComApiV1ConfigPlayerappRiot20ClientGetError,
        > = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get entitlement for remote requests with a token
pub async fn entitlements_auth_riotgames_com_api_token_v1_post(
    configuration: &configuration::Configuration,
) -> Result<
    models::EntitlementsAuthRiotgamesComApiTokenV1Post200Response,
    Error<EntitlementsAuthRiotgamesComApiTokenV1PostError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}//entitlements.auth.riotgames.com/api/token/v1",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EntitlementsAuthRiotgamesComApiTokenV1PostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the region for a given ID token and auth token. The ID token and auth token can be obtained from [PUT Cookie Reauth]
pub async fn riot_geo_pas_si_riotgames_com_pas_v1_product_valorant_put(
    configuration: &configuration::Configuration,
) -> Result<
    models::RiotGeoPasSiRiotgamesComPasV1ProductValorantPut200Response,
    Error<RiotGeoPasSiRiotgamesComPasV1ProductValorantPutError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}//riot_geo.pas.si.riotgames.com/pas/v1/product/valorant",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RiotGeoPasSiRiotgamesComPasV1ProductValorantPutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a PAS token using the auth token. The PAS token is a JWT that contains the affinity for the XMPP server.
pub async fn riot_geo_pas_si_riotgames_com_pas_v1_service_chat_get(
    configuration: &configuration::Configuration,
) -> Result<String, Error<RiotGeoPasSiRiotgamesComPasV1ServiceChatGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}//riot_geo.pas.si.riotgames.com/pas/v1/service/chat",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RiotGeoPasSiRiotgamesComPasV1ServiceChatGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
